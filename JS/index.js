// Hàm chuyển đổi mảng byte thành chuỗi hex
function bytesToHex(bytes) {
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += bytes[i].toString(16).padStart(2, "0");
  }
  return hex;
}
// Hàm chuyển đổi chuỗi hex thành mảng byte
function hexToBytes(hex) {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  return bytes;
}

// Hàm tạo khóa ECC
function generateECCKey() {
  const a = 2; // Hệ số a của đường cong elliptic
  const b = 3; // Hệ số b của đường cong elliptic
  const p = 17; // Số nguyên tố p
  const G = { x: 5, y: 1 }; // Điểm cơ sở G trên đường cong elliptic
  const n = 19; // Thứ tự của điểm G
  // Chọn số ngẫu nhiên k trong khoảng từ 1 đến n-1
  const k = Math.floor(Math.random() * (n - 1) + 1);
  // Tính toán khóa công khai P = k * G
  let P = { ...G }; // Khởi tạo P là điểm G
  for (let i = 2; i <= k; i++) {
    P = pointAddition(P, G, a, p);
  }
  // Trả về cặp khóa (khóa riêng tư và khóa công khai)
  return {
    privateKey: k,
    publicKey: bytesToHex([P.x, P.y]),
  };
}
// Hàm cộng hai điểm trên đường cong elliptic
function pointAddition(P, Q, a, p) {
  let lambda;
  if (P.x === Q.x && P.y === Q.y) {
    // Nếu P và Q cùng một điểm
    lambda = ((3 * Math.pow(P.x, 2) + a) * modInverse(2 * P.y, p)) % p;
  } else {
    // Nếu P và Q khác điểm
    lambda = ((Q.y - P.y) * modInverse(Q.x - P.x, p)) % p;
  }

  const x = (Math.pow(lambda, 2) - P.x - Q.x) % p;
  const y = (lambda * (P.x - x) - P.y) % p;

  return { x, y };
}
// Hàm tính nghịch đảo modulo
function modInverse(a, m) {
  for (let x = 1; x < m; x++) {
    if ((a * x) % m === 1) {
      return x;
    }
  }
  return 1;
}
// Sử dụng hàm tạo khóa ECC
const eccKey = generateECCKey();
console.log("Khóa riêng tư ECC:", eccKey.privateKey);
console.log("Khóa công khai ECC:", eccKey.publicKey);

// Hàm tạo khóa AES
function generateAESKey(keySize) {
  const randomBytes = new Uint8Array(keySize / 8); // Độ dài khóa được đo bằng bit, nên chia cho 8 để lấy độ dài byte
  for (let i = 0; i < randomBytes.length; i++) {
    randomBytes[i] = Math.floor(Math.random() * 128); // Tạo ngẫu nhiên các giá trị byte
  }
  const key = bytesToHex(randomBytes);
  return key;
}
// Sử dụng hàm tạo khóa AES
const keySize = 128; // Độ dài khóa AES (128, 192 hoặc 256-bit)

// Hàm thực hiện phép XOR hai mảng byte
function xorBytes(a, b) {
  const result = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return result;
}
// Hàm thực hiện phép dịch trái các byte trong mảng
function leftShiftBytes(bytes) {
  const result = new Uint8Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    result[i] = (bytes[i] << 1) | (bytes[(i + 1) % bytes.length] >> 7);
  }
  return result;
}
// Hàm thực hiện phép thay thế byte theo bảng S-box
function substituteByte(byte) {
  const sBox = [
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
    0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
    0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
    0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
    0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
    0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
    0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
    0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
    0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
    0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
    0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
    0xb0, 0x54, 0xbb, 0x16,
  ];

  return sBox[byte];
}

// Hàm thực hiện giai đoạn mã hóa SubBytes
function subBytes(state) {
  for (let i = 0; i < state.length; i++) {
    state[i] = substituteByte(state[i]);
  }
  return state;
}
// Hàm thực hiện giai đoạn mã hóa ShiftRows
function shiftRows(state) {
  const tempState = new Uint8Array(state.length);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      tempState[row + col * 4] = state[row + ((col + row) % 4) * 4];
    }
  }
  return tempState;
}
// Hàm thực hiện giai đoạn mã hóa MixColumns
function mixColumns(state) {
  const tempState = new Uint8Array(state.length);
  for (let col = 0; col < 4; col++) {
    const colOffset = col * 4;
    tempState[colOffset] =
      state[colOffset] ^
      state[colOffset + 1] ^
      state[colOffset + 2] ^
      state[colOffset + 3];
    const h = state[colOffset] ^ state[colOffset + 1];
    const x2 = state[colOffset + 1] ^ state[colOffset + 2];
    const x3 = state[colOffset + 2] ^ state[colOffset + 3];
    tempState[colOffset + 1] =
      h ^ leftShiftBytes([state[colOffset + 1], state[colOffset + 1]]) ^ x2;
    tempState[colOffset + 2] =
      x2 ^ leftShiftBytes([state[colOffset + 2], state[colOffset + 2]]) ^ x3;
    tempState[colOffset + 3] =
      x3 ^ leftShiftBytes([state[colOffset + 3], state[colOffset + 3]]);
  }
  return tempState;
}
// Hàm thực hiện giai đoạn mã hóa AddRoundKey
function addRoundKey(state, roundKey) {
  for (let i = 0; i < state.length; i++) {
    state[i] ^= roundKey[i];
  }
  return state;
}
// Hàm mã hóa thông tin bằng khóa AES
function encryptAES(plaintext, aesKey) {
  const rounds = 10; // Số vòng lặp
  const blockSize = 16; // Kích thước khối
  // Chia plaintext thành các khối có kích thước blockSize
  const blocks = [];
  for (let i = 0; i < plaintext.length; i += blockSize) {
    blocks.push(plaintext.slice(i, i + blockSize));
  }
  // Mã hóa từng khối
  const ciphertextBlocks = [];
  for (let i = 0; i < blocks.length; i++) {
    let block = blocks[i];
    // Thực hiện giai đoạn mã hóa khối
    block = addRoundKey(block, aesKey);
    for (let round = 1; round <= rounds; round++) {
      block = subBytes(block);
      block = shiftRows(block);
      if (round < rounds) {
        block = mixColumns(block);
      }
      block = addRoundKey(
        block,
        aesKey.slice(round * blockSize, (round + 1) * blockSize)
      );
    }
    ciphertextBlocks.push(block);
  }
  // Ghép các khối mã hóa thành ciphertext
  const ciphertext = new Uint8Array(plaintext.length);
  let offset = 0;
  for (let i = 0; i < ciphertextBlocks.length; i++) {
    ciphertext.set(ciphertextBlocks[i], offset);
    offset += blockSize;
  }
  return ciphertext;
}

const aesKey = generateAESKey(keySize);

console.log("Khóa AES: ", aesKey);

function Encode() {
  var plaintext = document.getElementById("string1").value;

  const ciphertext = encryptAES(plaintext, aesKey);

  const encode1 = bytesToHex(ciphertext);

  console.log("Đã mã hóa:", encode1);

  document.getElementById("encode1").value = encode1;

  document.getElementById("encode2").value = encode1;
}

function Decode() {
  const ciphertextString = document.getElementById("encode2").value;

  // Giải mã dữ liệu bằng khóa AES
  function decryptAES(ciphertext, sessionKey) {
    const Nb = 4; // Số cột trong một khối (block)
    const Nr = 10; // Số vòng lặp trong thuật toán AES-128
    const Nk = sessionKey.length / 4; // Số từ khóa (words) trong khóa

    function hexToBuffer(hexString) {
      const bufferLength = hexString.length / 2;
      const buffer = new Uint8Array(bufferLength);

      for (let i = 0; i < bufferLength; ++i) {
        buffer[i] = parseInt(hexString.substr(i * 2, 2), 16);
      }

      return buffer;
    }

    // Khởi tạo mảng trạng thái (state) từ chuỗi hex đầu vào
    let state = hexToBuffer(ciphertext);

    // Mở rộng khóa bằng thuật toán Key Expansion
    const expandedKey = keyExpansion(sessionKey, Nk, Nr);

    // Khám phá từng khối (block) trong dữ liệu mã hóa
    for (let i = 0; i < state.length; i += 16) {
      const block = state.subarray(i, i + 16);

      // Giải mã khối
      decryptBlock(block, expandedKey, Nr);

      // XOR với khối trước đó (ECB mode)
      if (i > 0) {
        for (let j = 0; j < 16; j++) {
          block[j] ^= state[i - 16 + j];
        }
      }
    }

    // Chuyển đổi mảng trạng thái thành chuỗi hex kết quả
    const decryptedData = bytesToHex(state);

    return decryptedData;
  }

  // Hàm thực hiện giải mã một khối (block) AES
  function decryptBlock(block, expandedKey, Nr) {
    const Nb = 4; // Số cột trong một khối (block)

    // Thực hiện phép XOR với vòng khóa cuối cùng
    addRoundKey(block, expandedKey, Nr * Nb, Nb);

    // Giải mã các vòng lặp trước đó
    for (let round = Nr - 1; round >= 1; round--) {
      invShiftRows(block);
      invSubBytes(block);
      addRoundKey(block, expandedKey, round * Nb, Nb);
      invMixColumns(block);
    }

    // Thực hiện phép XOR với vòng khóa đầu tiên
    invShiftRows(block);
    invSubBytes(block);
    addRoundKey(block, expandedKey, 0, Nb);
  }

  // Hàm thực hiện phép XOR với vòng khóa
  function addRoundKey(block, expandedKey, startIdx, Nb) {
    for (let i = 0; i < 16; i++) {
      block[i] ^= expandedKey[startIdx + i];
    }
  }

  // Hàm thực hiện phép dịch các hàng (shift rows)
  function invShiftRows(block) {
    const temp = new Uint8Array(16);

    // Di chuyển hàng thứ hai sang phải 1 vị trí
    temp[0] = block[0x0a];
    temp[1] = block[0x0e];
    temp[2] = block[0x02];
    temp[3] = block[0x06];

    // Di chuyển hàng thứ ba sang phải 2 vị trí
    temp[4] = block[0x03];
    temp[5] = block[0x07];
    temp[6] = block[0x0b];
    temp[7] = block[0x0f];

    // Di chuyển hàng thứ tư sang phải 3 vị trí
    temp[8] = block[0x08];
    temp[9] = block[0x0c];
    temp[10] = block[0x00];
    temp[11] = block[0x04];

    // Gán giá trị mới cho khối
    for (let i = 0; i < 16; i++) {
      block[i] = temp[i];
    }
  }

  // Hàm thực hiện phép thay thế các byte (sub bytes)
  function invSubBytes(block) {
    const SboxInv = [
      0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,
      0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
      0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32,
      0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
      0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
      0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
      0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50,
      0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
      0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,
      0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
      0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41,
      0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
      0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,
      0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
      0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
      0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
      0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,
      0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
      0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d,
      0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
      0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,
      0x55, 0x21, 0x0c, 0x7d,
    ];

    for (let i = 0; i < block.length; i++) {
      block[i] = SboxInv[block[i]];
    }
  }

  // Hàm thực hiện phép trộn cột (mix columns) ngược
  function invMixColumns(block) {
    for (let i = 0; i < 4; i++) {
      const offset = i * 4;

      const s0 = block[offset];
      const s1 = block[offset + 1];
      const s2 = block[offset + 2];
      const s3 = block[offset + 3];

      block[offset] =
        mult(0x0e, s0) ^ mult(0x0b, s1) ^ mult(0x0d, s2) ^ mult(0x09, s3);
      block[offset + 1] =
        mult(0x09, s0) ^ mult(0x0e, s1) ^ mult(0x0b, s2) ^ mult(0x0d, s3);
      block[offset + 2] =
        mult(0x0d, s0) ^ mult(0x09, s1) ^ mult(0x0e, s2) ^ mult(0x0b, s3);
      block[offset + 3] =
        mult(0x0b, s0) ^ mult(0x0d, s1) ^ mult(0x09, s2) ^ mult(0x0e, s3);
    }
  }

  // Hàm nhân hai số trong trường hữu hạn GF(2^8)
  function mult(a, b) {
    let result = 0;
    let temp = b;

    for (let i = 0; i < 8; i++) {
      if ((a & 0x01) === 1) {
        result ^= temp;
      }

      const carry = temp & 0x80;
      temp <<= 1;

      if (carry === 0x80) {
        temp ^= 0x1b;
      }

      a >>= 1;
    }

    return result;
  }

  // Hàm mở rộng khóa (Key Expansion) dựa trên thuật toán AES
  function keyExpansion(key, Nk, Nr) {
    const Nb = 4; // Số cột trong một khối (block)
    const expandedKeySize = Nb * (Nr + 1);
    const expandedKey = new Uint8Array(expandedKeySize * 4);

    // Copy khóa gốc vào khóa mở rộng
    for (let i = 0; i < Nk * 4; i++) {
      expandedKey[i] = key[i];
    }

    // Tạo từ khóa con
    for (let i = Nk; i < expandedKeySize; i++) {
      let temp = expandedKey.slice((i - 1) * 4, i * 4);

      if (i % Nk === 0) {
        temp = keyExpansionCore(temp, i / Nk);
      }

      for (let j = 0; j < 4; j++) {
        expandedKey[i * 4 + j] = expandedKey[(i - Nk) * 4 + j] ^ temp[j];
      }
    }

    return expandedKey;
  }

  // Hàm tạo từ khóa con (Key Expansion Core)
  function keyExpansionCore(word, iteration) {
    const temp = new Uint8Array(4);

    // Dịch vòng các byte trong từ khóa
    temp[0] = word[1];
    temp[1] = word[2];
    temp[2] = word[3];
    temp[3] = word[0];

    const Sbox = [
      0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
      0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
      0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
      0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
      0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
      0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
      0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
      0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
      0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
      0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
      0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
      0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
      0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
      0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
      0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
      0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
      0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
      0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
      0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
      0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
      0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
      0xb0, 0x54, 0xbb, 0x16,
    ];
    // Thay thế byte sử dụng S-box
    for (let i = 0; i < 4; i++) {
      temp[i] = Sbox[temp[i]];
    }

    const Rcon = [
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
    ];
    // Thực hiện phép XOR với hằng số
    temp[0] ^= Rcon[iteration];

    return temp;
  }

  const plaintextDecode = decryptAES(ciphertextString, aesKey);

  console.log("Đã giải mã: ", plaintextDecode);

  document.getElementById("string2").value = plaintextDecode;
}
